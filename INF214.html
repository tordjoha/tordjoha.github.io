<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>INF214</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div id="Lectures"><h1 id="Lectures" class="header"><a href="#Lectures">Lectures</a></h1></div>

<ul>
<li>
<a href="Guest Lecture.html">Guest Lecture</a> - Concurrency in Haskell 

</ul>
  
<div id="Exam prep"><h1 id="Exam prep" class="header"><a href="#Exam prep">Exam prep</a></h1></div>

<div id="Exam prep-1. Creating a thread in Java"><h2 id="1. Creating a thread in Java" class="header"><a href="#Exam prep-1. Creating a thread in Java">1. Creating a thread in Java</a></h2></div>
<ul>
<li>
<span id="Exam prep-1. Creating a thread in Java-Q:"></span><strong id="Q:">Q:</strong> What would happen if we didn't invoke method Thread.yield(); at line 11?

<li>
<span id="Exam prep-1. Creating a thread in Java-A:"></span><strong id="A:">A:</strong> If Thread.yield() was not invoked, what would happen is that the main thread would be executed first, and then the specified thread myThread, to a fairly certain degree.

</ul>

<div id="Exam prep-2. First lock"><h2 id="2. First lock" class="header"><a href="#Exam prep-2. First lock">2. First lock</a></h2></div>
<ul>
<li>
<span id="Exam prep-2. First lock-Q:"></span><strong id="Q:">Q:</strong> Run code given in video and what values were given and why?

<li>
<span id="Exam prep-2. First lock-A:"></span><strong id="A:">A:</strong> he code returns different values because without a type of synchronization of the threads, the threads will access the counter at the same time, and error occurs. Accessing at the same time means both will get the same value to increment from when one should have been incremented before the other, and the incrementation of one or the other will not be done properly.

</ul>

<div id="Exam prep-3. Playing with memory"><h2 id="3. Playing with memory" class="header"><a href="#Exam prep-3. Playing with memory">3. Playing with memory</a></h2></div>
<pre Java>
public void run(){
	while (!answerReady) {
		Thread.sleep(100);
	}
	System.out.println("The meaning of life is: " + answer);
}
</pre>
<ul>
<li>
<span id="Exam prep-3. Playing with memory-Q:"></span><strong id="Q:">Q:</strong> Modify method run() of the second thread t2 as follows, what implications does this have?

<li>
<span id="Exam prep-3. Playing with memory-A:"></span><strong id="A:">A:</strong> By modifying the code as such, the thread t2 would halt and sleep, until the condition becomes true, which would break the while loop and produce the output shown in the line under.

</ul>

<ul>
<li>
<span id="Exam prep-3. Playing with memory-Q:"></span><strong id="Q:">Q:</strong> What could have switched lines 8 and 9 in the video?

<li>
<span id="Exam prep-3. Playing with memory-A:"></span><strong id="A:">A:</strong> The compiler, JVM or the hardware could have "switched" the lines 8 and 9, because they are all allowed to optimize code by reordering.

</ul>

<ul>
<li>
<span id="Exam prep-3. Playing with memory-Q:"></span><strong id="Q:">Q:</strong> What are the three main problems that may lead to an unexpected behaviour of a concurrent program?

<li>
<span id="Exam prep-3. Playing with memory-A:"></span><strong id="A:">A:</strong> race condition, memory visibility and deadlock.

</ul>

<ul>
<li>
<span id="Exam prep-3. Playing with memory-Q:"></span><strong id="Q:">Q:</strong> To guarantee correct execution of a concurrent program, it is enough that:

<li>
<span id="Exam prep-3. Playing with memory-A:"></span><strong id="A:">A:</strong> both the reading and the writing thread use synchronization

</ul>

<div id="Exam prep-4. Multiple locks and Dining Philosophers"><h2 id="4. Multiple locks and Dining Philosophers" class="header"><a href="#Exam prep-4. Multiple locks and Dining Philosophers">4. Multiple locks and Dining Philosophers</a></h2></div>

<ul>
<li>
<span id="Exam prep-4. Multiple locks and Dining Philosophers-Q:"></span><strong id="Q:">Q:</strong> In code, how do we express "taking the left chopstick"? 

<li>
<span id="Exam prep-4. Multiple locks and Dining Philosophers-A:"></span><strong id="A:">A:</strong> synchronized(left)

</ul>


<ul>
<li>
<span id="Exam prep-4. Multiple locks and Dining Philosophers-Q:"></span><strong id="Q:">Q:</strong> Imagine that all the philosophers decide to eat at the same time, so they all grab their left chopstick. What will happen next?

<li>
<span id="Exam prep-4. Multiple locks and Dining Philosophers-A:"></span><strong id="A:">A:</strong> There will not be enough chopsticks for them to all eat at the same time, and they wont know what to do, the program will hang.

</ul>

<div id="Exam prep-5. Alien methods"><h2 id="5. Alien methods" class="header"><a href="#Exam prep-5. Alien methods">5. Alien methods</a></h2></div>
<ul>
<li>
<span id="Exam prep-5. Alien methods-Q:"></span><strong id="Q:">Q:</strong> Several methods are all  <em>synchronized</em>, can multiple threads call them without "interfering" with eachother?

<li>
<span id="Exam prep-5. Alien methods-A:"></span><strong id="A:">A:</strong> Yes, true

</ul>

<ul>
<li>
<span id="Exam prep-5. Alien methods-Q:"></span><strong id="Q:">Q:</strong> Methods addListener(), removeListener(), and updateProgress() are all synchronized.

</ul>
<p>
Can the deadlock still happen?
</p>
<ul>
<li>
<span id="Exam prep-5. Alien methods-A:"></span><strong id="A:">A:</strong> yes, the deadlock can still happen, because updateProgress() is calling an alien method, and that method could be aquiring another lock, and make a deadlock.

</ul>

<div id="Exam prep-Reentrant lock"><h2 id="Reentrant lock" class="header"><a href="#Exam prep-Reentrant lock">Reentrant lock</a></h2></div>
<ul>
<li>
<span id="Exam prep-Reentrant lock-Q:"></span><strong id="Q:">Q:</strong> Can we interrupt a thread that is blocked as a result of trying to acquire an intrinsic lock?

<li>
<span id="Exam prep-Reentrant lock-A:"></span><strong id="A:">A:</strong> No, false

</ul>

<ul>
<li>
<span id="Exam prep-Reentrant lock-Q:"></span><strong id="Q:">Q:</strong> Why did the deadlock happen at 07 min 15 sec?

<li>
<span id="Exam prep-Reentrant lock-A:"></span><strong id="A:">A:</strong> The deadlock at 7:15 happens because of the intrisic lock, and by rather using reentrant lock with the method lockInterruptedly(), it will work. That method acquires the lock unless the current thread is interrupted, which could happen here,

</ul>




















<p>
What does 'synchronized' do in Java?
What is a semaphore?
</p>

</body>
</html>
