<!DOCTYPE html>
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>INF214</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

<div id="Lectures"><h1 id="Lectures" class="header"><a href="#Lectures">Lectures</a></h1></div>

<ul>
<li>
<a href="Guest Lecture.html">Guest Lecture</a> - Concurrency in Haskell 

</ul>
  
<div id="Exam prep"><h1 id="Exam prep" class="header"><a href="#Exam prep">Exam prep</a></h1></div>

<div id="Exam prep-1. Creating a thread in Java"><h2 id="1. Creating a thread in Java" class="header"><a href="#Exam prep-1. Creating a thread in Java">1. Creating a thread in Java</a></h2></div>
<ul>
<li>
<span id="Exam prep-1. Creating a thread in Java-Q:"></span><strong id="Q:">Q:</strong> What would happen if we didn't invoke method Thread.yield(); at line 11?

<li>
<span id="Exam prep-1. Creating a thread in Java-A:"></span><strong id="A:">A:</strong> If Thread.yield() was not invoked, what would happen is that the main thread would be executed first, and then the specified thread myThread, to a fairly certain degree.

</ul>

<div id="Exam prep-2. First lock"><h2 id="2. First lock" class="header"><a href="#Exam prep-2. First lock">2. First lock</a></h2></div>
<ul>
<li>
<span id="Exam prep-2. First lock-Q:"></span><strong id="Q:">Q:</strong> Run code given in video and what values were given and why?

<li>
<span id="Exam prep-2. First lock-A:"></span><strong id="A:">A:</strong> he code returns different values because without a type of synchronization of the threads, the threads will access the counter at the same time, and error occurs. Accessing at the same time means both will get the same value to increment from when one should have been incremented before the other, and the incrementation of one or the other will not be done properly.

</ul>

<div id="Exam prep-3. Playing with memory"><h2 id="3. Playing with memory" class="header"><a href="#Exam prep-3. Playing with memory">3. Playing with memory</a></h2></div>
<pre Java>
public void run(){
	while (!answerReady) {
		Thread.sleep(100);
	}
	System.out.println("The meaning of life is: " + answer);
}
</pre>
<ul>
<li>
<span id="Exam prep-3. Playing with memory-Q:"></span><strong id="Q:">Q:</strong> Modify method run() of the second thread t2 as follows, what implications does this have?

<li>
<span id="Exam prep-3. Playing with memory-A:"></span><strong id="A:">A:</strong> By modifying the code as such, the thread t2 would halt and sleep, until the condition becomes true, which would break the while loop and produce the output shown in the line under.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-3. Playing with memory-Q:"></span><strong id="Q:">Q:</strong> What could have switched lines 8 and 9 in the video?

<li>
<span id="Exam prep-3. Playing with memory-A:"></span><strong id="A:">A:</strong> The compiler, JVM or the hardware could have "switched" the lines 8 and 9, because they are all allowed to optimize code by reordering.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-3. Playing with memory-Q:"></span><strong id="Q:">Q:</strong> What are the three main problems that may lead to an unexpected behaviour of a concurrent program?

<li>
<span id="Exam prep-3. Playing with memory-A:"></span><strong id="A:">A:</strong> race condition, memory visibility and deadlock.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-3. Playing with memory-Q:"></span><strong id="Q:">Q:</strong> To guarantee correct execution of a concurrent program, it is enough that:

<li>
<span id="Exam prep-3. Playing with memory-A:"></span><strong id="A:">A:</strong> both the reading and the writing thread use synchronization

</ul>

<div id="Exam prep-4. Multiple locks and Dining Philosophers"><h2 id="4. Multiple locks and Dining Philosophers" class="header"><a href="#Exam prep-4. Multiple locks and Dining Philosophers">4. Multiple locks and Dining Philosophers</a></h2></div>

<ul>
<li>
<span id="Exam prep-4. Multiple locks and Dining Philosophers-Q:"></span><strong id="Q:">Q:</strong> In code, how do we express "taking the left chopstick"? 

<li>
<span id="Exam prep-4. Multiple locks and Dining Philosophers-A:"></span><strong id="A:">A:</strong> synchronized(left)

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-4. Multiple locks and Dining Philosophers-Q:"></span><strong id="Q:">Q:</strong> Imagine that all the philosophers decide to eat at the same time, so they all grab their left chopstick. What will happen next?

<li>
<span id="Exam prep-4. Multiple locks and Dining Philosophers-A:"></span><strong id="A:">A:</strong> There will not be enough chopsticks for them to all eat at the same time, and they wont know what to do, the program will hang.

</ul>

<div id="Exam prep-5. Alien methods"><h2 id="5. Alien methods" class="header"><a href="#Exam prep-5. Alien methods">5. Alien methods</a></h2></div>
<ul>
<li>
<span id="Exam prep-5. Alien methods-Q:"></span><strong id="Q:">Q:</strong> Several methods are all  <em>synchronized</em>, can multiple threads call them without "interfering" with eachother?

<li>
<span id="Exam prep-5. Alien methods-A:"></span><strong id="A:">A:</strong> Yes, true

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-5. Alien methods-Q:"></span><strong id="Q:">Q:</strong> Methods addListener(), removeListener(), and updateProgress() are all synchronized. Can the deadlock still happen?

<li>
<span id="Exam prep-5. Alien methods-A:"></span><strong id="A:">A:</strong> yes, the deadlock can still happen, because updateProgress() is calling an alien method, and that method could be aquiring another lock, and make a deadlock.

</ul>

<div id="Exam prep-Reentrant lock"><h2 id="Reentrant lock" class="header"><a href="#Exam prep-Reentrant lock">Reentrant lock</a></h2></div>
<ul>
<li>
<span id="Exam prep-Reentrant lock-Q:"></span><strong id="Q:">Q:</strong> Can we interrupt a thread that is blocked as a result of trying to acquire an intrinsic lock?

<li>
<span id="Exam prep-Reentrant lock-A:"></span><strong id="A:">A:</strong> No, false

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-Reentrant lock-Q:"></span><strong id="Q:">Q:</strong> Why did the deadlock happen at 07 min 15 sec?

<li>
<span id="Exam prep-Reentrant lock-A:"></span><strong id="A:">A:</strong> The deadlock at 7:15 happens because of the intrisic lock, and by rather using reentrant lock with the method lockInterruptedly(), it will work. That method acquires the lock unless the current thread is interrupted, which could happen here,

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-Reentrant lock-Q:"></span><strong id="Q:">Q:</strong> What is a livelock?

<li>
<span id="Exam prep-Reentrant lock-A:"></span><strong id="A:">A:</strong> A livelock is when all threads time out at the same time, and then entering deadlock again.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-Reentrant lock-Q:"></span><strong id="Q:">Q:</strong> What is the difference between methods lock() and tryLock()?

<li>
<span id="Exam prep-Reentrant lock-A:"></span><strong id="A:">A:</strong> A tryLock() times out if it fails to acquire a lock, while lock() doesnt do that.

</ul>

<div id="Exam prep-7. Linked list"><h2 id="7. Linked list" class="header"><a href="#Exam prep-7. Linked list">7. Linked list</a></h2></div>
<ul>
<li>
<span id="Exam prep-7. Linked list-Q:"></span><strong id="Q:">Q:</strong> How could you explain hand-over-hand locking?

<li>
<span id="Exam prep-7. Linked list-A:"></span><strong id="A:">A:</strong> Hand-over-hand locking works by only locking a small part of something, such that the whole object wont be locked and cant be interacted with. In a list hand-over-hand locking can be used to only lock a few elements at a time, instead of the whole list.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-7. Linked list-Q:"></span><strong id="Q:">Q:</strong> Class ReentrantLock supports a fairness parameter. How do you think, what does it mean for a lock to be “fair”? 

<li>
<span id="Exam prep-7. Linked list-A:"></span><strong id="A:">A:</strong> I think the fairness parameter thinks about time, and how long something has been locked or something like that, and by being fair i think the ReentrantLock prioritizes threads that has been locked the longest.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-7. Linked list-Q:"></span><strong id="Q:">Q:</strong> Method insert() acquires locks starting with the head of the list. Assume we have another method that would acquire locks starting with the tail of the list (this, for example, could be your implementation of the method size()). Is it true that in such case we would break the rule of acquiring locks in a global, fixed order?

<li>
<span id="Exam prep-7. Linked list-A:"></span><strong id="A:">A:</strong> No, false

</ul>

<div id="Exam prep-8. Condition variables"><h2 id="8. Condition variables" class="header"><a href="#Exam prep-8. Condition variables">8. Condition variables</a></h2></div>
<ul>
<li>
<span id="Exam prep-8. Condition variables-Q:"></span><strong id="Q:">Q:</strong> What is the difference between methods signal() and signalAll()?

<li>
<span id="Exam prep-8. Condition variables-A:"></span><strong id="A:">A:</strong> signal() wakes up one waiting thread, while signalAll() wakes up every waiting thread.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-8. Condition variables-Q:"></span><strong id="Q:">Q:</strong> Why is the solution of the Dining Philosophers Problem that uses condition variables better than our previous solutions?

<li>
<span id="Exam prep-8. Condition variables-A:"></span><strong id="A:">A:</strong> It's better because this solution covers every possible solution to eating and waiting, while the other solutions could not counter the possibility of only one philosopher eating, and having only one chopstick available. 

</ul>


<div id="Exam prep-9. Atomic variables"><h2 id="9. Atomic variables" class="header"><a href="#Exam prep-9. Atomic variables">9. Atomic variables</a></h2></div>
<ul>
<li>
<span id="Exam prep-9. Atomic variables-Q:"></span><strong id="Q:">Q:</strong> What are the advantages of using atomic variables?

<li>
<span id="Exam prep-9. Atomic variables-A:"></span><strong id="A:">A:</strong> The advantages of using atomic variables are that there is no locks, so not possible to deadlock or get asynchronized.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-9. Atomic variables-Q:"></span><strong id="Q:">Q:</strong> What are "volatile" variables? 

<li>
<span id="Exam prep-9. Atomic variables-A:"></span><strong id="A:">A:</strong> By marking variables as volatile, you guarantee that they are written to and read from main memory, instead of the cache. Without using volatile you have no control over when the JVM reads or writes to and from cache to main memory or vice versa.

</ul>


<div id="Exam prep-10. Recap, Await language, Pre/Post-condition"><h2 id="10. Recap, Await language, Pre/Post-condition" class="header"><a href="#Exam prep-10. Recap, Await language, Pre/Post-condition">10. Recap, Await language, Pre/Post-condition</a></h2></div>
<ul>
<li>
<span id="Exam prep-10. Recap, Await language, Pre/Post-condition-Q:"></span><strong id="Q:">Q:</strong> What is a preconditon? 

<li>
<span id="Exam prep-10. Recap, Await language, Pre/Post-condition-A:"></span><strong id="A:">A:</strong> A precondition is whats assumed to be true before a program runs

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-10. Recap, Await language, Pre/Post-condition-Q:"></span><strong id="Q:">Q:</strong> What is a postcondition?

<li>
<span id="Exam prep-10. Recap, Await language, Pre/Post-condition-A:"></span><strong id="A:">A:</strong> A postcondition is what will be true after a program is ran - if it terminates.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-10. Recap, Await language, Pre/Post-condition-Q:"></span><strong id="Q:">Q:</strong> Preconditions and postconditions are not executed?

<li>
<span id="Exam prep-10. Recap, Await language, Pre/Post-condition-A:"></span><strong id="A:">A:</strong> True

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-10. Recap, Await language, Pre/Post-condition-Q:"></span><strong id="Q:">Q:</strong> What does parralell execution operator (co S_1 || S_2 || ... || S_n oc

</ul>
<p>
) terminate?
</p>
<ul>
<li>
<span id="Exam prep-10. Recap, Await language, Pre/Post-condition-A:"></span><strong id="A:">A:</strong> When all processes S_1, ..., S_n terminates

</ul>

<div id="Exam prep-11. Sequential consistency"><h2 id="11. Sequential consistency" class="header"><a href="#Exam prep-11. Sequential consistency">11. Sequential consistency</a></h2></div>
<ul>
<li>
<span id="Exam prep-11. Sequential consistency-Q:"></span><strong id="Q:">Q:</strong> What is data race?

<li>
<span id="Exam prep-11. Sequential consistency-A:"></span><strong id="A:">A:</strong> Data race is when two processes concurrently access the same memory location and at least one of them is a write operation. Accesses are not synchronized.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-11. Sequential consistency-Q:"></span><strong id="Q:">Q:</strong> Consider the following program:
<pre>
co x=x+1; || x=x-1; oc
</pre>

<ul>
<li>
Assume that before this program is executed, the value of variable x is 0. We have discussed in the video that after this program is executed, the possible values of x are -1; 0; and 1. In your own words, what could be the reason for that? 

</ul>
<li>
<span id="Exam prep-11. Sequential consistency-A:"></span><strong id="A:">A:</strong> A reason for that could be because when the program is ran concurrently,  both the compiler and hardware have the ability to reorder the statements which are being done concurrently, and because the possible values of x depends on the order of which the operations proceed, we can get these different values of x.

</ul>

<div id="Exam prep-12. Atomic operations"><h2 id="12. Atomic operations" class="header"><a href="#Exam prep-12. Atomic operations">12. Atomic operations</a></h2></div>
<ul>
<li>
<span id="Exam prep-12. Atomic operations-Q:"></span><strong id="Q:">Q:</strong> Atomic operations cannot be subdivided, but all intermediate states of the execution are visible to other processes?

<li>
<span id="Exam prep-12. Atomic operations-A:"></span><strong id="A:">A:</strong> False

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-12. Atomic operations-Q:"></span><strong id="Q:">Q:</strong> In general, a statement with at least one atomic operation can be considered atomic?

<li>
<span id="Exam prep-12. Atomic operations-A:"></span><strong id="A:">A:</strong> False

</ul>

<div id="Exam prep-13. Interleaving example"><h2 id="13. Interleaving example" class="header"><a href="#Exam prep-13. Interleaving example">13. Interleaving example</a></h2></div>
<ul>
<li>
<span id="Exam prep-13. Interleaving example-Q:"></span><strong id="Q:">Q:</strong> Write down the list of reads and writes in the following statement:
<pre>
x = a * b + c / d + sin(y*10*z);
</pre>

<ul>
<li>
Use "READ x" to denote that a variable x is read, and "WRITE x" to denote that a variable x is written to.

</ul>
<li>
<span id="Exam prep-13. Interleaving example-A:"></span><strong id="A:">A:</strong> READ a * READ b + READ c / READd + sin(READ y * 10 * READ z) = WRITE x

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-13. Interleaving example-Q:"></span><strong id="Q:">Q:</strong> Consider the following paralell excution statement:
<pre>
co x = x + 1; || x = x + 1; oc
</pre>

<ul>
<li>
Assume that before executing this statement, the value of variable x is 0. In other words, the precondition is that x==0.

<li>
What are the possible values of x after this statement is executed? (In other words, what is the postcondition?)

</ul>
<li>
<span id="Exam prep-13. Interleaving example-A:"></span><strong id="A:">A:</strong> The Postcondition is  either x = =1 or  x == 2. 

</ul>

<div id="Exam prep-14. Atomic actions, At-Most-Once property"><h2 id="14. Atomic actions, At-Most-Once property" class="header"><a href="#Exam prep-14. Atomic actions, At-Most-Once property">14. Atomic actions, At-Most-Once property</a></h2></div>
<ul>
<li>
<span id="Exam prep-14. Atomic actions, At-Most-Once property-Q:"></span><strong id="Q:">Q:</strong> Given an assignment statement "z = e", when does it have at-most-once property?

<li>
<span id="Exam prep-14. Atomic actions, At-Most-Once property-A:"></span><strong id="A:">A:</strong> It has at-most-once property if either <span id="Exam prep-14. Atomic actions, At-Most-Once property-e"></span><strong id="e">e</strong> contains at most one critical reference, and <span id="Exam prep-14. Atomic actions, At-Most-Once property-z"></span><strong id="z">z</strong> is not read by another process. It would also satisfy a.m.o if <span id="Exam prep-14. Atomic actions, At-Most-Once property-e"></span><strong id="e">e</strong> does not contain any critical references.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-14. Atomic actions, At-Most-Once property-Q:"></span><strong id="Q:">Q:</strong> Let V be the set of global variables in a statement or an expression; and let W be the set of global write-variables. Assume we have two statements S1 and S2.  How to formally express, using V and W, that S1 and S2 have no common variables?

<li>
<span id="Exam prep-14. Atomic actions, At-Most-Once property-A:"></span><strong id="A:">A:</strong> That can be formally expressed like this: V(S1)   ∩  V(S2) = Ø

</ul>

<div id="Exam prep-15. Await statement"><h2 id="15. Await statement" class="header"><a href="#Exam prep-15. Await statement">15. Await statement</a></h2></div>
<ul>
<li>
<span id="Exam prep-15. Await statement-Q:"></span><strong id="Q:">Q:</strong> What is mutual exclusion?

<li>
<span id="Exam prep-15. Await statement-A:"></span><strong id="A:">A:</strong> Mutual exclusion is a type of synchronization that ensures that statements in different processes cannot execute at the same time.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-15. Await statement-Q:"></span><strong id="Q:">Q:</strong> What is condition synchronization?

<li>
<span id="Exam prep-15. Await statement-A:"></span><strong id="A:">A:</strong> Condition  synchronization is a type of synchronization that involves delaying a process until some boolean condition is true.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-15. Await statement-Q:"></span><strong id="Q:">Q:</strong> Assume that statement S is an assignment statement, and assume that it has the at-most-once property. Will it be executed atomically in this case?

<li>
<span id="Exam prep-15. Await statement-A:"></span><strong id="A:">A:</strong> True

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-15. Await statement-Q:"></span><strong id="Q:">Q:</strong> Assume that a statement S is implemented by a single machine instruction. Will it be executed atomically in this case?

<li>
<span id="Exam prep-15. Await statement-A:"></span><strong id="A:">A:</strong> True

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-15. Await statement-Q:"></span><strong id="Q:">Q:</strong> Assume that S is a block of statements, and one of the statements in S has the at-most-once property. Will the block S be executed atomically in this case?

<li>
<span id="Exam prep-15. Await statement-A:"></span><strong id="A:">A:</strong> False

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-15. Await statement-Q:"></span><strong id="Q:">Q:</strong> Assume that S is a block of statements, and all but one of the statements in S have the at-most-once property. Will the block S be executed atomically in this case?

<li>
<span id="Exam prep-15. Await statement-A:"></span><strong id="A:">A:</strong> False

</ul>

<div id="Exam prep-16. Properties of concurrent programs"><h2 id="16. Properties of concurrent programs" class="header"><a href="#Exam prep-16. Properties of concurrent programs">16. Properties of concurrent programs</a></h2></div>
<ul>
<li>
<span id="Exam prep-16. Properties of concurrent programs-Q:"></span><strong id="Q:">Q:</strong> Let P be a predicate over program history, i.e. a property. Assume that P is true for all possible histories of a given program. How is such property P then called?

<li>
<span id="Exam prep-16. Properties of concurrent programs-A:"></span><strong id="A:">A:</strong> If this is the case, then the property P is called a True property.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-16. Properties of concurrent programs-Q:"></span><strong id="Q:">Q:</strong> Give an example of a non-terminating program in your favourite programming language. Please don't forget to mention what language you used.

<li>
<span id="Exam prep-16. Properties of concurrent programs-A:"></span><strong id="A:">A:</strong> a while loop which never stops because condition is always true

</ul>

<div id="Exam prep-17. Safety and liveness properties"><h2 id="17. Safety and liveness properties" class="header"><a href="#Exam prep-17. Safety and liveness properties">17. Safety and liveness properties</a></h2></div>
<ul>
<li>
<span id="Exam prep-17. Safety and liveness properties-Q:"></span><strong id="Q:">Q:</strong> What is a safety property? Give examples

<li>
<span id="Exam prep-17. Safety and liveness properties-A:"></span><strong id="A:">A:</strong> Safety property says that the final state is correct, and examples of this can be mutual exclusion, and the absence of a deadlock.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-17. Safety and liveness properties-Q:"></span><strong id="Q:">Q:</strong> What is a liveness property? Give examples

<li>
<span id="Exam prep-17. Safety and liveness properties-A:"></span><strong id="A:">A:</strong> Liveness property says that the program will terminate, and examples of liveness properties are:

<ul>
<li>
a request of service will eventually be honored

<li>
a message will eventually reach its destination

</ul>
</ul>

<div id="Exam prep-18. Scheduling policies and fairness"><h2 id="18. Scheduling policies and fairness" class="header"><a href="#Exam prep-18. Scheduling policies and fairness">18. Scheduling policies and fairness</a></h2></div>
<ul>
<li>
<span id="Exam prep-18. Scheduling policies and fairness-Q:"></span><strong id="Q:">Q:</strong> What is meant by "eligible atomic action"?

<li>
<span id="Exam prep-18. Scheduling policies and fairness-A:"></span><strong id="A:">A:</strong> When an atomic action is an "eligible atomic action", that means that it is the next atomic action in the process that could be executed.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-18. Scheduling policies and fairness-Q:"></span><strong id="Q:">Q:</strong> Which kinds of scheduling policies were mentioned in the video?

<li>
<span id="Exam prep-18. Scheduling policies and fairness-A:"></span><strong id="A:">A:</strong> unconditional fairness, weak fairness, strong fairness

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-18. Scheduling policies and fairness-Q:"></span><strong id="Q:">Q:</strong> How does round-robin work?

<li>
<span id="Exam prep-18. Scheduling policies and fairness-A:"></span><strong id="A:">A:</strong> Round robin works by giving processes time slices in equal portions and in circular order.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-18. Scheduling policies and fairness-Q:"></span><strong id="Q:">Q:</strong> What is a weakly fair scheduling policy?

<li>
<span id="Exam prep-18. Scheduling policies and fairness-A:"></span><strong id="A:">A:</strong> A weakly fair scheduling policy is a scheduling policy which is unconditionally fair, and every atomic action that is eligible will eventually be executed, assuming its condition becomes true and remains true until it is sen by the process that executes the conditional atomic action.

</ul>

<div id="Exam prep-19. Critical section problem"><h2 id="19. Critical section problem" class="header"><a href="#Exam prep-19. Critical section problem">19. Critical section problem</a></h2></div>
<ul>
<li>
<span id="Exam prep-19. Critical section problem-Q:"></span><strong id="Q:">Q:</strong> Can a solution to critical section problem be used to implement await statements?

<li>
<span id="Exam prep-19. Critical section problem-A:"></span><strong id="A:">A:</strong> True

</ul>

<ul>
<li>
<span id="Exam prep-19. Critical section problem-Q:"></span><strong id="Q:">Q:</strong> Which properties must the entry and exit protocols satisfy?

<li>
<span id="Exam prep-19. Critical section problem-A:"></span><strong id="A:">A:</strong> They must satisfy: Mutual exclusion, Absence of deadlock(livelock) , Absence of unneccesary delay and Eventual entry.

</ul>

<div id="Exam prep-20. Spin locks, Test and Set, Test and Test and Set"><h2 id="20. Spin locks, Test and Set, Test and Test and Set" class="header"><a href="#Exam prep-20. Spin locks, Test and Set, Test and Test and Set">20. Spin locks, Test and Set, Test and Test and Set</a></h2></div>
<ul>
<li>
<span id="Exam prep-20. Spin locks, Test and Set, Test and Test and Set-Q:"></span><strong id="Q:">Q:</strong> Given a Boolean variable b, what is the semantics of the Test-and-Set instruction?

<li>
<span id="Exam prep-20. Spin locks, Test and Set, Test and Test and Set-A:"></span><strong id="A:">A:</strong> &lt;bool x=b; b=true; return x;&gt; 

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-20. Spin locks, Test and Set, Test and Test and Set-Q:"></span><strong id="Q:">Q:</strong> Consider the Test and Test and Set instruction:
<pre>
while(lock) {} 
while(TestAndSet(lock)) {
   while(lock) {}
}
</pre>

<ul>
<li>
What is special abiut the first and third uses of variable lock?

</ul>
<li>
<span id="Exam prep-20. Spin locks, Test and Set, Test and Test and Set-A:"></span><strong id="A:">A:</strong> The process tests the lock until there is a possibility that TestAndSet can succeed, and the first and third uses of lock are of type spinlock.

</ul>

<div id="Exam prep-21. Implementing await statements"><h2 id="21. Implementing await statements" class="header"><a href="#Exam prep-21. Implementing await statements">21. Implementing await statements</a></h2></div>
<ul>
<li>
<span id="Exam prep-21. Implementing await statements-Q:"></span><strong id="Q:">Q:</strong> Explain in your own ideas, why do we use <span id="Exam prep-21. Implementing await statements-Delay"></span><strong id="Delay">Delay</strong>?

<li>
<span id="Exam prep-21. Implementing await statements-A:"></span><strong id="A:">A:</strong> We use delay because it is smart to make a process wait before reentering the critical section, because of the memory.

</ul>

<div id="Exam prep-22. Tie-breaker algorithm"><h2 id="22. Tie-breaker algorithm" class="header"><a href="#Exam prep-22. Tie-breaker algorithm">22. Tie-breaker algorithm</a></h2></div>
<ul>
<li>
<span id="Exam prep-22. Tie-breaker algorithm-Q:"></span><strong id="Q:">Q:</strong> Spin-lock solutions require a weakly fair scheduler to ensure eventual entry?

<li>
<span id="Exam prep-22. Tie-breaker algorithm-A:"></span><strong id="A:">A:</strong> False

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-22. Tie-breaker algorithm-Q:"></span><strong id="Q:">Q:</strong> Suppose we have two processes: P1 and P2. Suppose the entry protocol for the process P1 is this:
<pre>
in1 = true;
while(in2) { skip; }
</pre>

<ul>
<li>
Suppose also that the entry protocol for the process P2 is this:
<pre>
in2 = true;
while(in1) { skip; } 
</pre>

<li>
Is mutual exclusion ensured in this case?

</ul>
<li>
<span id="Exam prep-22. Tie-breaker algorithm-A:"></span><strong id="A:">A:</strong> True, yes

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-22. Tie-breaker algorithm-Q:"></span><strong id="Q:">Q:</strong> Suppose we have the entry protocols for two processes exactly as described in the previous question. Can deadlock happen?

<li>
<span id="Exam prep-22. Tie-breaker algorithm-A:"></span><strong id="A:">A:</strong> True, yes

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-22. Tie-breaker algorithm-Q:"></span><strong id="Q:">Q:</strong> What is the meaning behind variable 'last'?

<li>
<span id="Exam prep-22. Tie-breaker algorithm-A:"></span><strong id="A:">A:</strong> It indicates which process, P1 or P2, was the last to start executing its entry protocol 

</ul>

<div id="Exam prep-23. Ticket algorithm"><h2 id="23. Ticket algorithm" class="header"><a href="#Exam prep-23. Ticket algorithm">23. Ticket algorithm</a></h2></div>
<ul>
<li>
<span id="Exam prep-23. Ticket algorithm-Q:"></span><strong id="Q:">Q:</strong> Let x be an integer variable, and let z be an integer value. What is the semantics of the Fetch-and-Add instruction FA(x, z)?

<li>
<span id="Exam prep-23. Ticket algorithm-A:"></span><strong id="A:">A:</strong> &lt;int tmp = x; x = x+ z; return tmp; &gt; 

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-23. Ticket algorithm-Q:"></span><strong id="Q:">Q:</strong> Explain in your own words what the Fetch-and-Add instruction does.

<li>
<span id="Exam prep-23. Ticket algorithm-A:"></span><strong id="A:">A:</strong> The fetch-and-add instruction gets a value from memory, increments it and then returns it.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-23. Ticket algorithm-Q:"></span><strong id="Q:">Q:</strong> In the ticket algorithm, consider the following entry protocol:
<pre>
turn[i]=FA(number, 1);
while(turn[i] != next) skip;
</pre>

<ul>
<li>
Is this fine-grained or coarse-grained protocol? 

</ul>
<li>
<span id="Exam prep-23. Ticket algorithm-A:"></span><strong id="A:">A:</strong> Fine-grained

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-23. Ticket algorithm-Q:"></span><strong id="Q:">Q:</strong> If the ticket algorithm runs for a very long time, incrementing a counter will eventually cause arithmetic overflow. However, this is very unlikely to happen in practice.

<li>
<span id="Exam prep-23. Ticket algorithm-A:"></span><strong id="A:">A:</strong> False

</ul>

<div id="Exam prep-24. Barriers intro"><h2 id="24. Barriers intro" class="header"><a href="#Exam prep-24. Barriers intro">24. Barriers intro</a></h2></div>
<ul>
<li>
<span id="Exam prep-24. Barriers intro-Q:"></span><strong id="Q:">Q:</strong> Explain in your own words, how you understand barrier synchronization.

<li>
<span id="Exam prep-24. Barriers intro-A:"></span><strong id="A:">A:</strong> The way i understand barrier synchronization is that its called barrier synchronization because the processes must all wait before they can continue, and they are all "stuck" behind this "barrier" waiting for all the tasks to be complete.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-24. Barriers intro-This statement is true:"></span><strong id="This statement is true:">This statement is true:</strong> Suppose we have <span id="Exam prep-24. Barriers intro-n"></span><strong id="n">n</strong> processes that need to meet at a barrier. When a process arrives at the barrier, it increments <span id="Exam prep-24. Barriers intro-count"></span><strong id="count">count</strong>. When <span id="Exam prep-24. Barriers intro-count"></span><strong id="count">count</strong> is equal to <span id="Exam prep-24. Barriers intro-n"></span><strong id="n">n</strong>, all processes can proceed. 

</ul>

<div id="Exam prep-25. Flags and coordinators"><h2 id="25. Flags and coordinators" class="header"><a href="#Exam prep-25. Flags and coordinators">25. Flags and coordinators</a></h2></div>
<ul>
<li>
<span id="Exam prep-25. Flags and coordinators-Q:"></span><strong id="Q:">Q:</strong> What are the flag synchronization principles? 

<li>
<span id="Exam prep-25. Flags and coordinators-A:"></span><strong id="A:">A:</strong> Flag should not be set before its known that its clear to do so, the same process that waits for sync flag should also be the one to clear it.

</ul>

<div id="Exam prep-26. Symmetric barriers"><h2 id="26. Symmetric barriers" class="header"><a href="#Exam prep-26. Symmetric barriers">26. Symmetric barriers</a></h2></div>
<ul>
<li>
<span id="Exam prep-26. Symmetric barriers-This statement is true:"></span><strong id="This statement is true:">This statement is true:</strong> To construct a two-process barrier, we could use the coordinator worker technique. 

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-26. Symmetric barriers-Q:"></span><strong id="Q:">Q:</strong> Consider the following barrier code for worker process W[i]:
<pre>
&lt;await(arrive[i]==0);&gt;
arrive[i]=1;
&lt;await(arrive[j])==1);&gt;
arrive[j]=0;
</pre>

<ul>
<li>
The first line waits for a process's own flag to be cleared. Why is that needed? 

</ul>
<li>
<span id="Exam prep-26. Symmetric barriers-A:"></span><strong id="A:">A:</strong> To guard against the possible situation when a processes races back to the barrier and sets its own flag before the other process from the previous use of the barrier cleared the flag

</ul>

<div id="Exam prep-27. Semaphores intro"><h2 id="27. Semaphores intro" class="header"><a href="#Exam prep-27. Semaphores intro">27. Semaphores intro</a></h2></div>
<ul>
<li>
<span id="Exam prep-27. Semaphores intro-Q:"></span><strong id="Q:">Q:</strong> The value of a semaphore is a positive integer?

<li>
<span id="Exam prep-27. Semaphores intro-A:"></span><strong id="A:">A:</strong> False, its a boolean value

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-27. Semaphores intro-Q:"></span><strong id="Q:">Q:</strong> The V operation is used to signal the occurence of event

<li>
<span id="Exam prep-27. Semaphores intro-A:"></span><strong id="A:">A:</strong> True

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-27. Semaphores intro-Q:"></span><strong id="Q:">Q:</strong> The P operation is used to delay a process until an event is occured 

<li>
<span id="Exam prep-27. Semaphores intro-A:"></span><strong id="A:">A:</strong> True

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-27. Semaphores intro-Q:"></span><strong id="Q:">Q:</strong> The V operation increments the value of a semaphpore

<li>
<span id="Exam prep-27. Semaphores intro-A:"></span><strong id="A:">A:</strong> True

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-27. Semaphores intro-Q:"></span><strong id="Q:">Q:</strong> The P operation waits until the value of a semaphore is positive and then decrements the value

<li>
<span id="Exam prep-27. Semaphores intro-A:"></span><strong id="A:">A:</strong> True

</ul>
<hr />
<ul>
<li>
The default value of a semaphore declared as (sem s;) is 0.

</ul>

<div id="Exam prep-28. Semaphores and Critical Section Problem"><h2 id="28. Semaphores and Critical Section Problem" class="header"><a href="#Exam prep-28. Semaphores and Critical Section Problem">28. Semaphores and Critical Section Problem</a></h2></div>
<ul>
<li>
<span id="Exam prep-28. Semaphores and Critical Section Problem-Q:"></span><strong id="Q:">Q:</strong> In the critical section problem that uses semaphores, what is the entry protocol?

<li>
<span id="Exam prep-28. Semaphores and Critical Section Problem-A:"></span><strong id="A:">A:</strong> Waiting for sem mutex to be 1

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-28. Semaphores and Critical Section Problem-Q:"></span><strong id="Q:">Q:</strong> What is the exit protocol?

<li>
<span id="Exam prep-28. Semaphores and Critical Section Problem-A:"></span><strong id="A:">A:</strong> Setting the sem mutex to 0

</ul>

<div id="Exam prep-29. Semaphores and Barriers"><h2 id="29. Semaphores and Barriers" class="header"><a href="#Exam prep-29. Semaphores and Barriers">29. Semaphores and Barriers</a></h2></div>
<ul>
<li>
<span id="Exam prep-29. Semaphores and Barriers-True statement:"></span><strong id="True statement:">True statement:</strong> Semaphores make it relatively easy to implement barrier synchronization. The basic idea is to use one semaphore for each synchronization flag. A process set a flag by executing a <span id="Exam prep-29. Semaphores and Barriers-V"></span><strong id="V">V</strong> operation

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-29. Semaphores and Barriers-True statement:"></span><strong id="True statement:">True statement:</strong> A process waits for a flag to be set and then clears it by executing a <span id="Exam prep-29. Semaphores and Barriers-P"></span><strong id="P">P</strong> operation.

</ul>

<div id="Exam prep-30. Producers and Consumers"><h2 id="30. Producers and Consumers" class="header"><a href="#Exam prep-30. Producers and Consumers">30. Producers and Consumers</a></h2></div>
<ul>
<li>
<span id="Exam prep-30. Producers and Consumers-Q:"></span><strong id="Q:">Q:</strong> Describe in your own words what Runnable interface is.

<li>
<span id="Exam prep-30. Producers and Consumers-A:"></span><strong id="A:">A:</strong> Runnable interface is an interface which is very useful and should be used when writing classes where something is going to be run and executed by threads. It gives Thread options for running and can f.eks be used to show when a thread is active or not. 

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-30. Producers and Consumers-Q:"></span><strong id="Q:">Q:</strong> What does the following command do?
<pre>
queue.put(new PoisonPill());
</pre>

<li>
<span id="Exam prep-30. Producers and Consumers-A:"></span><strong id="A:">A:</strong> The command tells that the data for processing has been finished and consumer should finish its work.

</ul>

<div id="Exam prep-31. Producers and Consumers - more"><h2 id="31. Producers and Consumers - more" class="header"><a href="#Exam prep-31. Producers and Consumers - more">31. Producers and Consumers - more</a></h2></div>
<ul>
<li>
<span id="Exam prep-31. Producers and Consumers - more-Q:"></span><strong id="Q:">Q:</strong> What does the synchronization requirement "c &lt;= p &lt;= c + 1" mean?

<li>
<span id="Exam prep-31. Producers and Consumers - more-A:"></span><strong id="A:">A:</strong> c and p can differ by at most one, the producer can deposit at most one 1 element more that the consumer has fetched.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-31. Producers and Consumers - more-Q:"></span><strong id="Q:">Q:</strong> Is it true that when p == c, then the buffer is empty?

<li>
<span id="Exam prep-31. Producers and Consumers - more-A:"></span><strong id="A:">A:</strong> Yes, true

</ul>

<div id="Exam prep-32. Producers and Consumers - Split binary semaphores"><h2 id="32. Producers and Consumers - Split binary semaphores" class="header"><a href="#Exam prep-32. Producers and Consumers - Split binary semaphores">32. Producers and Consumers - Split binary semaphores</a></h2></div>
<ul>
<li>
<span id="Exam prep-32. Producers and Consumers - Split binary semaphores-Q:"></span><strong id="Q:">Q:</strong> Why is it necessary that the execution of deposit and fetch alternates?

<li>
<span id="Exam prep-32. Producers and Consumers - Split binary semaphores-A:"></span><strong id="A:">A:</strong> It is necessary for deposit and fetch to alternate because then we make sure that messages are not overwritten and only  fetched once.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-32. Producers and Consumers - Split binary semaphores-Q:"></span><strong id="Q:">Q:</strong> What is the "intuition" behind a fact that semaphore empty=1?

<li>
<span id="Exam prep-32. Producers and Consumers - Split binary semaphores-A:"></span><strong id="A:">A:</strong> The "intuition" behind empty being 1 is because the 1 signals that the make_buffer_empty event has occured, and by making this one we show that something has happened, as opposed to 0 that "signals" that nothing has happened yet.

</ul>

<div id="Exam prep-33. Semaphores and Bounded Buffers"><h2 id="33. Semaphores and Bounded Buffers" class="header"><a href="#Exam prep-33. Semaphores and Bounded Buffers">33. Semaphores and Bounded Buffers</a></h2></div>
<ul>
<li>
<span id="Exam prep-33. Semaphores and Bounded Buffers-Q:"></span><strong id="Q:">Q:</strong> What is the next element after buf[n-1]=

<li>
<span id="Exam prep-33. Semaphores and Bounded Buffers-A:"></span><strong id="A:">A:</strong> buf[0] or 0

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-33. Semaphores and Bounded Buffers-Q:"></span><strong id="Q:">Q:</strong> When neither deposit or fetch are being executed, what is the sum of the values of the semaphores empty and full, i.e. empty+full?

<li>
<span id="Exam prep-33. Semaphores and Bounded Buffers-A:"></span><strong id="A:">A:</strong> n or N or empty+full=N/n

</ul>

<div id="Exam prep-34. Semaphores and Dining Philosophers"><h2 id="34. Semaphores and Dining Philosophers" class="header"><a href="#Exam prep-34. Semaphores and Dining Philosophers">34. Semaphores and Dining Philosophers</a></h2></div>
<ul>
<li>
<span id="Exam prep-34. Semaphores and Dining Philosophers-Q:"></span><strong id="Q:">Q:</strong> How do we express "picking up a fork" using a semaphore? 

<li>
<span id="Exam prep-34. Semaphores and Dining Philosophers-A:"></span><strong id="A:">A:</strong> By executing P(sem) like this:  P(fork[i])

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-34. Semaphores and Dining Philosophers-Q:"></span><strong id="Q:">Q:</strong> Why do we have a special implementation of the process Philosopher[4]?

<li>
<span id="Exam prep-34. Semaphores and Dining Philosophers-A:"></span><strong id="A:">A:</strong> We do this to avoid deadlock and for circular deadlock to not occur we get Philosopher4 pick up the right fork first.

</ul>

<div id="Exam prep-35. Readers Writers problem"><h2 id="35. Readers Writers problem" class="header"><a href="#Exam prep-35. Readers Writers problem">35. Readers Writers problem</a></h2></div>
<ul>
<li>
<span id="Exam prep-35. Readers Writers problem-Q:"></span><strong id="Q:">Q:</strong> Explain (briefly) the Readers/Writers problem in your own words.

<li>
<span id="Exam prep-35. Readers Writers problem-A:"></span><strong id="A:">A:</strong> The readers/writers problem is about readers and writers who both want to access a shared location, e.g a document. A reader should access the document while no writers are accessing, and a writer should not access the document while another writer is current accessing the document. This is about mutual exclusion of the two processes; reader and writer, and the general problem lies in when and how these two processes access the shared location.

</ul>
<hr />
<ul>
<li>
<span id="Exam prep-35. Readers Writers problem-Q:"></span><strong id="Q:">Q:</strong> How do we express the following atomic action using an (extra) semaphore:
<pre>
&lt;
x = x + 1
if (condition) P(s);
&gt;
</pre>

<li>
<span id="Exam prep-35. Readers Writers problem-A:"></span><strong id="A:">A:</strong> 
<pre>
sem mutexFirst = sem mutexSecond = 1;

P(mutexSecond);

x = x + 1;

if (x == 1) P(mutexFirst);

V(mutexSecond);
</pre>

</ul>

<div id="Exam prep-37. Readers Writers - Passing the baton"><h2 id="37. Readers Writers - Passing the baton" class="header"><a href="#Exam prep-37. Readers Writers - Passing the baton">37. Readers Writers - Passing the baton</a></h2></div>
<ul>
<li>
<span id="Exam prep-37. Readers Writers - Passing the baton-Q:"></span><strong id="Q:">Q:</strong>

<li>
<span id="Exam prep-37. Readers Writers - Passing the baton-A:"></span><strong id="A:">A:</strong>

</ul>











<p>
What does 'synchronized' do in Java?
What is a semaphore?
</p>

</body>
</html>
